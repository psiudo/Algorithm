
"""
읽기 + 구상 : 5분 30초 / 코드 : 5분 / 디버깅 : 2분 + 12분 / 실패횟수 : 1
"""
###############################################################
"""
1~N일 상담가능 / N+1일에는 x
튜플의 첫 원소만큼 인덱스를 미뤄서 선택하기
"""

"""
생각 안한 거는 ,,,, N+1일에는 X인데,, 왜,,
"""

N = int(input())
lst = [] # [(3, 10), (5, 20), (1, 10), (1, 20), (2, 15), (4, 40), (2, 200)]
for _ in range(1, N+1) :
    lst.append(tuple(map(int, input().split())))

# ========================================================
best = 0
def dfs(s_idx, curr_sum) :
    global best

    # 종료조건이 너무 애매하다. 알아서 잘 끝났음 좋겠는데?
    #
    # if s_idx >= N :
    #     best = max(curr_sum, best)
    #     return

    for idx in range(s_idx, N) : # 조합이니까 방문 배열 불필요, 선형적으로 증가
        if idx + lst[idx][0] <= N :
            """
            여기서 N-1인지 N인지 헷갈렸는데
            지금 1인덱스에서는 N까지 된댔으니까 0인덱스는 N-1이라 생각해서 그런 것 같은데
            시작 인덱스랑 끝나는 날이랑 다르잖아요,,,
            """
            dfs(idx + (lst[idx][0]), curr_sum + lst[idx][1])
    else :
        best = max(curr_sum, best)
        return

# =========================================================
dfs(0, 0)
print(best)